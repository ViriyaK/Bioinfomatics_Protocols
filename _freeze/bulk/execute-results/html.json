{
  "hash": "a3032ee4608f4085c7b7ced54c7f7f31",
  "result": {
    "markdown": "---\nexecute:\n  eval: false\nformat:\n  html:\n    link-external-newwindow: true\n---\n\n\n# Bulk Analysis {#sec-Bulk_Analysis}\n\nThis chapter is for the downstream analysis of the most common bulk NGS experiments we perform. For functional analysis that are common to all these methods, see next chapter.\n\n## RNA-Seq\n\nWhile RPKM has some issues and is not the most correct quantification, for basic comparison, this is good enough to share with biologists. The nf-core pipeline will provide this value by default.\n\n### Differential Gene Expression\n\nOne of the most basic and common analysis on RNA-Seq. We use DESeq2 and their well documented [vignette](https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html) is worth reading from start to end for the beginner.\n\n::: callout-note\nWhile our pipeline originally used the `STAR --quantMode` to quantify genes, with switching to nf-core, we are also switching to [STAR](https://github.com/alexdobin/STAR/blob/master/doc/STARmanual.pdf) alignment followed by [RSEM](https://github.com/deweylab/RSEM) quantification.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nfiles <- list.files(path = \"./working_dir\", pattern = \"*genes.results$\", full.names = TRUE)\nrsem_results <- lapply(files, read_delim)\nexpected_counts_list <- lapply(rsem_results, function(x) { x$expected_count })\nexpected_counts <- do.call(cbind, expected_counts_list) %>% as.data.frame()\n```\n:::\n\n\nRSEM produces non-integer counts, and we can by-pass that by using `round()`. Alternatively, you can use [tximport](https://bioconductor.org/packages/devel/bioc/vignettes/tximport/inst/doc/tximport.html) to read the files in.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpected_counts <- round(expected_counts) \nrownames(expected_counts) <- rsem_results[[1]]$gene_id\ncolnames(expected_counts) <- stringr::str_extract(files, \"mr\\\\d+\") # our RNA-seq samples usually start with MR\n\nsampleTable <- data.frame(condition = factor(rep(c(\"control\", \"knockdown\"), each = 3)),\n                          replicate = factor(rep(seq(1,3))))\nrownames(sampleTable) <- colnames(expected_counts)\n```\n:::\n\n\n**DESeq2**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndds <- DESeqDataSetFromMatrix(expected_counts, sampleTable, design = ~condition)\nkeep <- rowSums(counts(dds)) > 10\ndds <- dds[keep,]\ndds <- DESeq(dds)\nres <- results(dds, alpha = 0.01)\nsummary(res)\n```\n:::\n\n\nDifference between rlog, vst and lfcShrink <https://support.bioconductor.org/p/104615/>.\n\n**Plotting PCs**\n\nDESeq2's `plotPCA()` function will plot the top 500 most variable genes. The chunk below will plot all genes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndegenes <- res %>% subset(padj < 0.01)\ndds_rlog <- rlog(dds)\npca_data <- t(assay(dds_rlog)) %>% prcomp()\nautoplot(pca_data, data = sampleTable, colour = \"condition\") + \n  geom_text_repel(label = rownames(sampleTable))\nrlog_de <- assay(dds_rlog) %>% subset(rownames(dds_rlog) %in% rownames(degenes))\nrlog_de_scaled <- t(scale(t(rlog_de)))\n```\n:::\n\n\nAfter getting DEGs, you'd want to group the genes into biological functions. See @sec-enrichment for Over representation analysis (ORA) with GO and KEGG terms as well as Gene Set Enrichment Analysis (GSEA) with ranked genes.\n\n### Deciding Groups and Plotting\n\nWhile you can use k-means manually to get seperate groups, [ComplexHeatmap](https://jokergoo.github.io/ComplexHeatmap-reference/book/index.html) allows you to do so with more [flexiblity](https://jokergoo.github.io/ComplexHeatmap-reference/book/a-single-heatmap.html#heatmap-split) and get visualizations as well.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat_colors <- list(\n  replicate = c(brewer.pal(3, \"Accent\")),\n  condition = c(brewer.pal(6, \"Set1\")))\nnames(mat_colors$replicate) <- unique(sampleTable$replicate)\nnames(mat_colors$condition) <- sampleTable$condition\n\ncol_anno <- HeatmapAnnotation(df = sampleTable,\n                              which = 'col',\n                              col = mat_colors\n)\n\nhmap <- Heatmap(rlog_de_scaled,\n                   name = \"scaled\",\n                   \n                   # Row Params\n                   show_row_names = FALSE,\n                   row_title_rot=0,\n                   cluster_row_slices = FALSE,\n                   border = TRUE,\n                   row_km = 2, # split rows into 2 groups\n                   \n                   # Column Params\n                   cluster_columns = FALSE,\n                   column_title = \"Rlog Transformed Expression for all DE genes\",\n                   top_annotation = col_anno)\nhmap <- draw(hmap) # assigning so that k-means is only called once\nrow_order(hmap) # grab the different groups in rows\n```\n:::\n\n\nSee [here](https://jokergoo.github.io/ComplexHeatmap-reference/book/a-single-heatmap.html#get-orders-and-dendrograms-from-heatmap) for why we assign `draw()`.\n\n## ChIP-Seq and ATAC-Seq\n\n### Spike-in normalization\n[Guidelines](https://www.activemotif.com/documents/1977.pdf) on spike-in normalization from ActiveMotif.\n\n1. Perform ChIP combining the Spike-in Chromatin, Spike-in Antibody, test chromatin and test antibody into the same tube for immunoprecipitation. We suggest using the guidelines provided for chromatin and antibody quantities based on the antibody target.\n2. Follow ChIP with Next-Generation Sequencing.\n3. Map ChIP-seq data to the test reference genome (e.g. human, mouse or other).\n4. Map ChIP-seq data to the Drosophila reference genome.\n5. Count uniquely aligning Drosophila sequence tags and identify the sample containing the least number of tags.\n6. Compare Drosophila tag counts from other samples to the sample containing the least tags and generate a normalization factor for\neach comparison.\n (Sample 1 with lowest tag count / Sample 2) = Normalization factor\n7. Downsample the tag counts of data sets proportional to the normalization factor determined\n\n### Peak calling\n\nDepending on if you use the nfcore's pipeline or your own, you will have to call peaks. I use MACS2 and here are some details I've gathered.\\\n<https://github.com/crazyhottommy/ChIP-seq-analysis/blob/master/part1.3_MACS2_peak_calling_details.md>\n\nWhy I skip model building <https://github.com/macs3-project/MACS/issues/391>\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nmacs2 callpeak -t mxx_sorted.bam --outdir macs/mxx -n mxx -g hs -q 0.01 --nomodel --shift 0 --extsize 250\n```\n:::\n\n\n### Overlapping peaks\n\nAfter MACS2 peak-calling, we may want to see how many peaks overlap in different conditions. Even though it's named [mergePeaks](http://homer.ucsd.edu/homer/ngs/mergePeaks.html), you will be able to get overlapping statistics from this. Be mindful of long path names as mergePeaks will produce errors.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nmergePeaks -d 100 pu1.peaks cebp.peaks -prefix mmm -venn venn.txt\n```\n:::\n\n\n::: callout-tip\nThe -d flag changes the unique peaks to 100 bp each and keep the shared peaks same size.\\\nTo get literal 1bp overlap, just omit -d argument altogether\n:::\n\nThe easiest way to plot this result is with [Vennerable](https://github.com/js229/Vennerable).\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- tot[1]\nb <- tot[2]\nab <- tot[3]\n\nvenn_obj <- createVennObj(nSets = 2, sNames = c(\"m1043\", \"m1044\"), # names in order of first to last\n                     sSizes = c(0, a, b ,ab))\nvp <- plotVenn(nVennObj = venn_obj)\n```\n:::\n\n\nThis gets tedious with more than 2 sets. See code below. You should not make Venn Diagrams with more than 4 sets. An upset plot is better in that scenario.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\n# 3 sets -----\na <- tot[1]\nb <- tot[2]\nab <- tot[3]\nc <- tot[4]\nac <- tot[5]\nbc <- tot[6]\nabc <- tot[7]\n\n# 4 sets -------\na <- tot[1]\nb <- tot[2]\nab <- tot[3]Ve\nc <- tot[4]\nac <- tot[5]\nbc <- tot[6]\nabc <- tot[7]\nd <- tot[8]\nad <- tot[9]\nbd <- tot[10]\nabd <- tot[11]\ncd <- tot[12]\nacd <- tot[13]\nbcd <- tot[14]\nabcd <- tot[15]\n```\n:::\n\n\nThis is a more automated way of reading in the data, here using 4 sets as an example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvenn <- read.table(\"results/output_nepc.bedpe\", header = TRUE, sep = \"\\t\")\nvenn$alpha <- apply(venn, 1, function(x) {\n  sets <- c(\"A\", \"B\", \"C\", \"D\")\n  selected_sets <- sets[which(x == \"X\")]\n  paste(selected_sets, collapse = \"\")\n})\n\norder_vector <- c(\"0\", \"A\", \"B\", \"AB\", \"C\", \"AC\", \"BC\", \"ABC\", \"D\", \"AD\", \"BD\", \"ABD\", \"CD\", \"ACD\", \"BCD\", \"ABCD\")\n\nvenn$alpha <- factor(venn$alpha, levels = order_vector)\n\n# Sort the data frame based on the factor levels\nvenn <- venn[order(venn$alpha), ]\nvenn_plot <- Venn(SetNames = c(\"93\", \"145.1\", \"145.2\", \"nci\"), \n                  Weight = c(0, venn$Features))\nplot(venn_plot, type = \"ellipses\")\n```\n:::\n\n\nCreating upset plots <https://github.com/hms-dbmi/UpSetR>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(UpSetR)\nvenn$Sets <- apply(venn[, -1], 1, function(x) {\n  sets <- colnames(venn)[2:17]\n  selected_sets <- sets[which(x == \"X\")]\n  paste(selected_sets, collapse = \"&\")\n})\n\nupset_input <- c(venn$Features)\nnames(upset_input) <- venn$Sets\nupset(fromExpression(upset_input), nsets = 16, nintersects = 100, number.angles = 45)\n```\n:::\n\n\nA sample script to automate this process. I haven't incorporated the above part into this script.\n\n\n::: {.cell filename='mergePeaksandplot.sh'}\n\n```{.bash .cell-code}\nmodule load homer/4.10\nmodule load R/4.0.3\nmergePeaks control_peaks.narrowPeak purturbed_peaks.narrowPeak -prefix ov -venn venn.txt\n# n_way script, venn.txt, last sample label, middle samples label, first sample label, txt file name (no extension)\nRscript --vanilla venn2way.R venn.txt purturbed control venn\n```\n:::\n\n\nThe accompanying R file:\n\n\n::: {.cell filename='venn2way.R'}\n\n```{.r .cell-code}\nlibrary(Vennerable)\n\nargs <- commandArgs(trailingOnly = TRUE)\n\nvenn <- read.table(args[1], header = TRUE, sep = \"\\t\")\ntot <- venn[[Total]]\n\na <- tot[1]\nb <- tot[2]\nab <- tot[3]\n\nvenner <- Venn(SetNames = c(args[3], args[2]), # opposite labelling to nVennR, going from last sample to first\n               Weight = c(0, b, a, ab))\npng(paste0(args[4], \".png\"))\nplot(venner)\ndev.off()\n```\n:::\n\n\nTo make Venn Diagrams that are more accurately weighted, use [nVennR](https://cran.r-project.org/web/packages/nVennR/index.html). Sadly, it looks like it's been removed from CRAN since the last time I've installed it.\n\nIf you have replicates, overlapping peaks can be obtained via packages like [MAnorm2](https://cran.r-project.org/web/packages/MAnorm2/index.html). Read more about dealing with replicates [here](https://ro-che.info/articles/2018-07-11-chip-seq-consensus).\n\n### Motif Enrichment\n\nHomer `mergePeaks` is able to take the narrowPeaks format as input, but if you're doing homer `mergePeaks` first and then `findMotifs`, you need to change the Homer `mergePeaks` output to exclude the header line first. This also applies to deepTools heatmaps.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nfindMotifsGenome.pl peak_or_bed /projects/p20023/Viriya/software/Homer4.10/data/genomes/hg38/ output_dir -size 200 \n```\n:::\n\n\n-size 200 is the default, and is calculated from the center of the peaks. If your peaks are bigger and you wish to use the entire region, use `-size given`. However, when the regions are too large, motifs will not be significantly enriched.\n\n### Plotting Heatmaps\n\nHere I'm showing a sample [deepTools](https://deeptools.readthedocs.io/en/latest/) script to plot heatmaps. First you need bigwig files. `bamCoverage` offers normalization by scaling factor, Reads Per Kilobase per Million mapped reads (RPKM), counts per million (CPM), bins per million mapped reads (BPM) and 1x depth (reads per genome coverage, RPGC).\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nbamCoverage --bam m${i}_sorted.bam --outFileName m${i}.bw --normalizeUsing CPM \\\n--extendReads 200 --numberOfProcessors 6 --binSize 20\n```\n:::\n\n\nI find having paths defined at the top of the script makes it less likely to have mistakes.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nday3=\"m1015_1055_hg38/foxa2/CPM\"\nnci=\"m1015_1055_hg38/CPM\"\nchip=\"../Viriya/analysis/foxa2/chip-seq\"\n\ncomputeMatrix reference-point --referencePoint center -S \\\n$day3/m674.bw $day3/m676.bw $tf/m914.bw $tf/m921.bw $nci/m1043.bw $nci/m1044.bw \\\n-R $chip/clustering/output/1.bed \\\n$chip/clustering/output/2.bed \\\n$chip/clustering/output/3.bed \\\n$chip/clustering/output/4.bed \\\n-a 3000 -b 3000 -o $chip/heatmaps/scaled_FOXA2_sites.npz \\\n--samplesLabel m674 m676 m914 m921 m1043 m1044 \\\n-p max --blackListFileName $chip/ENCFF356LFX.bed.gz\n\nplotHeatmap -m $chip/FOXA2_6_samples/heatmaps/scaled_FOXA2_sites.npz \\\n-o $chip/FOXA2_6_samples/heatmaps/scaled_FOXA2_sites.pdf \\\n--colorMap Blues\n\n```\n:::\n\n\n`--sortUsingSamples` is not 0 indexed. 1st sample is 1. `--sortUsingSamples` is also usable in plotHeatmap so we can save that to there for more flexible plotting.\n\n`--regionsLabel`: \"xxx binding sites n=2390\" put it in quotes if you don't want to key in escape too many times\n\n`--sampleLabels`: if you're sure you're not going to change any labels, put it in makeheatmap step because fewer things to type when redoing the heatmap multiple times due to scaling etc, therefore fewer mistakes. otherwise put it in plotHeatmap.\n\nIn legends: \"Pol II\" spaces and parantheses need to be escaped, but not + signs.\n\nUse BED6 format annd not the BED3 if you care about strandedness <https://github.com/deeptools/deepTools/issues/886>.\n\nTo get sorted output bed files, use the `--sortedOutRegions` at the plotHeatmap step, not computeMatrix.\\\nUse `--clusterUsingSamples` for a more robust delineation.\n\n### Genomic Annotation\n\n[ChIPSeeker](https://bioconductor.org/packages/release/bioc/html/ChIPseeker.html)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(org.Hs.eg.db)\nlibrary(TxDb.Hsapiens.UCSC.hg38.knownGene)\n\npromoter <- getPromoters(TxDb=txdb, upstream=3000, downstream=3000)\n\nmxxx <- readPeakFile(\"/path_to_narrowPeak/mxxx_peaks.narrowPeak\")\ntagMatrix <- getTagMatrix(mxxx, windows = promoter) # usually needs an interactive job\npeakAnno <- annotatePeak(mxxx, tssRegion = c(-3000,3000), TxDb = txdb, annoDb = \"org.Hs.eg.db\")\nplotAnnoPie(peakAnno, main = \"mxxx\", line = -6)\nvennpie(peakAnno, r = 0.1)\nupsetplot(peakAnno) + ggtitle(\"mxxx\")\nplotAnnoBar(peakAnno)\n```\n:::\n\n\n`annotatePeak` will default to chosing one gene per region. This is fine for small binding sites but for larger regions use `seq2gene` as it will map genomic regions in a many-to-many manner.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}